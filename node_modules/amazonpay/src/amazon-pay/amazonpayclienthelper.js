'use strict';

const constants = require('./constants.js');
const xml2js = require('xml2js');
const request = require('request');
const crypto = require('crypto');
const URL = require('url');

exports.addToMap = function (canonicalParams, paramKey, paramValue) {
    if (typeof paramValue !== 'undefined') {
        canonicalParams[paramKey] = paramValue;
    }
}

exports.addArrayToMap = function (canonicalParams, paramKey, paramValue) {
    if (typeof paramValue !== 'undefined') {
        const length = paramValue.length;

        for (let count = 0; count < length; count++) {
            canonicalParams[`${paramKey}.${count + 1}`] = paramValue[count];
        }
    }
}

exports.addBaseParams = function (canonicalParams, action, configArgs, requestParams) {
    const requestParamsCopy = { ...requestParams };
    this.addToMap(canonicalParams, 'AWSAccessKeyId', configArgs.accessKey);
    this.addToMap(canonicalParams, 'Action', action);
    this.addToMap(canonicalParams, 'SellerId',
        (requestParamsCopy.merchantId || configArgs.merchantId));
    this.addToMap(canonicalParams, 'MWSAuthToken', requestParamsCopy.mwsAuthToken);
}

exports.getUserInfo = function (accessToken, configArgs) {
    /** Check if the Access Token belongs to either the Client ID or App ID
     *   If check completes get the user info
     */

    const tokenInfoEndpoint = `${this.getProfileEndpointUri(configArgs)}/auth/o2/tokeninfo?access_token=${this.rfcEncode(accessToken)}`;
    const userProfileEndpoint = `${this.getProfileEndpointUri(configArgs)}/user/profile?access_token=${this.rfcEncode(accessToken)}`;
    const headerVals = [];
    const options = {
        method: 'get',
        json: false,
        headers: headerVals,
        url: tokenInfoEndpoint,
        body: ''
    };
    const check = sendUserInfoRequest(options);

    return check.then(function (result) {
        const body = JSON.parse(result.body);
        if (body.aud !== configArgs.clientId &&
            body.app_id !== configArgs.appId) {
            return Promise.reject(new Error('The Access Token belongs to neither your Client ID nor App ID'));
        } else {
            const headerVals = [];
            const options = {
                method: 'get',
                json: false,
                headers: headerVals,
                url: userProfileEndpoint,
                body: ''
            };

            const response = sendUserInfoRequest(options);

            return response.then(function (result) {
                const userResult = JSON.parse(result.body);
                userResult.statusCode = result.statusCode;
                return userResult;
            }).catch(err => {
                return Promise.reject(err);
            });
        }
    }).catch(err => {
        return Promise.reject(err);
    });
}

exports.sendParam = function (requestParams, configArgs) {
    const requestParamsCopy = { ...requestParams };

    requestParamsCopy.Timestamp = this.getTimestamp();
    requestParamsCopy.SignatureMethod = constants.SIGNATURE_METHOD;
    requestParamsCopy.SignatureVersion = constants.SIGNATURE_VERSION;
    requestParamsCopy.Version = constants.API_VERSION;

    const endpoint = this.getEndpoint(configArgs);

    requestParamsCopy.Signature = this.signRequest(endpoint, requestParamsCopy, configArgs);

    const sortedReqParams = this.sortRequestParameters(requestParamsCopy);
    const canonicalQuery = this.getParametersAsString(sortedReqParams, requestParamsCopy);
    const headerVals = this.getHeaders();

    const options = {
        method: 'post',
        json: false,
        headers: headerVals,
        url: endpoint,
        body: canonicalQuery
    };

    const count = 1;
    const response = this.retryLogic(options, count);

    return response;
}

exports.retryLogic = function (options, count) {
    const response = this.sendRequest(options, count);

    if (count > constants.RETRIES) {
        return response.then(function (result) {
            return result;
        }).catch(err => {
            return Promise.reject(err);
        });
    }

    return response.then(function (result) {
        return result;
    }).catch(err => {
        if (err.statusCode >= 500 && err.statusCode < 600) {
            return this.retryLogic(options, count += 1);
        } else {
            return Promise.reject(err);
        }
    })
}

exports.sendRequest = function (options, count) {
    const delayTime = count === 1 ? 0 : (2 ** (count - 1)) * 1000;

    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            request(options, function (err, response, body) {
                if (err) {
                    reject(err);
                } else if (response.statusCode >= 400 && response.statusCode < 600) {
                    reject(response);
                } else {
                    resolve(response);
                }
            });
        }, delayTime);
    });
}

function sendUserInfoRequest(options) {
    return new Promise(function (resolve, reject) {
        request(options, function (err, response, body) {
            if (err) {
                reject(err);
            } else if (response.statusCode != 200){
                const errResponse = JSON.parse(response.body);
                errResponse.statusCode = response.statusCode;
                reject(errResponse);
            } else {
                resolve(response);
            }
        });
    });
}

exports.getHeaders = function () {
    const headers = {
        'content-type': 'application/x-www-form-urlencoded',
        'user-agent': this.constructUserAgentHeader()
    };

    return headers;
}

exports.constructUserAgentHeader = function () {
    return `amazon-pay-sdk-nodejs/${constants.VERSION} (JS/${process.version.node}; ${process.platform})`;
}

exports.signRequest = function (endpoint, requestParams, configArgs) {
    const requestParamsCopy = { ...requestParams };
    const secretKey = Buffer.from(configArgs.secretKey);
    const sortedReqParams = this.sortRequestParameters(requestParamsCopy);
    const parseEndpoint = URL.parse(endpoint);
    const canonicalQuery = this.getParametersAsString(sortedReqParams, requestParamsCopy);
    const hmac = crypto.createHmac(constants.HASH_ALGORITHM, secretKey);
    const stringToSign = [
        'POST',
        parseEndpoint.hostname,
        (parseEndpoint.pathname || '/'),
        canonicalQuery,
    ].join('\n');
    hmac.update(stringToSign);
    requestParamsCopy.Signature = hmac.digest('base64');

    return requestParamsCopy.Signature;
}

exports.sortRequestParameters = function (requestParams) {
    const requestParamsCopy = { ...requestParams };
    const sortedReqParams = Object.keys(requestParamsCopy).sort();

    return sortedReqParams;
}

exports.getParametersAsString = function (sortedParams, requestParams) {
    const requestParamsCopy = { ...requestParams };
    for (const key in requestParamsCopy) {
        requestParamsCopy[key] = this.rfcEncode(requestParamsCopy[key]);
    }
    const canonicalQuery = sortedParams.map(function (key) {
        return `${key}=${requestParamsCopy[key]}`;
    }).join('&');

    return canonicalQuery;
}

/** URI Encoding input */
exports.rfcEncode = function (str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return '%' + c.charCodeAt(0).toString(16);
    });
}

exports.getTimestamp = function () {
    const date = new Date();

    return date.toISOString().split('.')[0] + 'Z';
}

exports.getProfileEndpointUri = function (configArgs) {
    const sandbox = configArgs.sandbox ? 'api.sandbox' : 'api';

    return `https://${sandbox}.${this.getProfileEndpointRegion(configArgs)}`;
}

exports.getProfileEndpointRegion = function (configArgs) {
    return constants.PROFILE_ENDPOINT_URLS[configArgs.region.toLowerCase()];
}
exports.getEndpoint = function (configArgs) {
    const sandbox = configArgs.sandbox ? '_Sandbox/' : '/';

    return `https://${this.getRegion(configArgs)}/OffAmazonPayments${sandbox}${constants.API_VERSION}`;
}

exports.getRegion = function (configArgs) {
    return constants.REGION_MAP[configArgs.region.toLowerCase()];
}

exports.jsonResponse = function (response, formatOption, requestAction) {
    let jsonOutput = '';
    const parser = new xml2js.Parser({ explicitArray: false, trim: true, ignoreAttrs: true });

    return response.then(function (result) {
        const responseData = (result.body).toString();
        parser.parseString(responseData, function (err, parseResult) {
            if (err) {
                return Promise.reject(err);
            }
            const parsedXML = parseResult[`${requestAction}Response`];
            if (formatOption === 'jsonString') {
                jsonOutput = JSON.stringify(parsedXML);
            } else if (formatOption === 'jsonObject') {
                jsonOutput = parsedXML;
                jsonOutput.statusCode = result.statusCode;
            } else {
                jsonOutput = result.body;
            }
        });
        return jsonOutput;
    }, function (err) {
        return Promise.reject(err);
    }).catch(err => {
        return this.errorParsing(err, formatOption);
    });
}

exports.errorParsing = function (response, formatOption) {
    let errOutput = '';
    const parser = new xml2js.Parser({ explicitArray: false, trim: true, ignoreAttrs: true });
    if (response.message) {
        return Promise.reject(response);
    } else {
        const errData = (response.body).toString();
        parser.parseString(errData, function (err, parseResult) {
            if (err) {
                return Promise.reject(err);
            }
            const parsedXML = parseResult.ErrorResponse;
            if (formatOption === 'jsonString') {
                errOutput = JSON.stringify(parsedXML);
            } else if (formatOption === 'jsonObject') {
                errOutput = parsedXML;
                errOutput.statusCode = response.statusCode;
            } else {
                errOutput = response.body;
            }
        });
        return Promise.reject(errOutput);
    }
}

exports.jsonOrXML = function (formatOption, response, requestAction) {
    return this.jsonResponse(response, (formatOption || 'xml'), requestAction);
}